<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.3.7: http://docutils.sourceforge.net/" />
<title>VJDBC Reference</title>
<meta name="author" content="Michael Link" />
<link rel="stylesheet" href="reference.css" type="text/css" />
</head>
<body>
<div class="document" id="vjdbc-reference">
<h1 class="title">VJDBC Reference</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Michael Link</td></tr>
<tr><th class="docinfo-name">Version:</th>
<td>1.6.3 (08.04.2006)</td></tr>
</tbody>
</table>
<div class="contents topic" id="contents">
<p class="topic-title first"><a name="contents">Contents</a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#introduction" id="id9" name="id9">1&nbsp;&nbsp;&nbsp;Introduction</a><ul class="auto-toc">
<li><a class="reference" href="#what-is-vjdbc" id="id10" name="id10">1.1&nbsp;&nbsp;&nbsp;What is VJDBC ?</a></li>
<li><a class="reference" href="#features" id="id11" name="id11">1.2&nbsp;&nbsp;&nbsp;Features</a></li>
<li><a class="reference" href="#compatibility" id="id12" name="id12">1.3&nbsp;&nbsp;&nbsp;Compatibility</a></li>
</ul>
</li>
<li><a class="reference" href="#supported-protocols" id="id13" name="id13">2&nbsp;&nbsp;&nbsp;Supported Protocols</a><ul class="auto-toc">
<li><a class="reference" href="#rmi" id="id14" name="id14">2.1&nbsp;&nbsp;&nbsp;RMI</a></li>
<li><a class="reference" href="#http-s-using-servlets" id="id15" name="id15">2.2&nbsp;&nbsp;&nbsp;HTTP(S) using Servlets</a></li>
<li><a class="reference" href="#ejb-mode" id="id16" name="id16">2.3&nbsp;&nbsp;&nbsp;EJB-Mode</a></li>
</ul>
</li>
<li><a class="reference" href="#configuration-usage" id="id17" name="id17">3&nbsp;&nbsp;&nbsp;Configuration &amp; Usage</a><ul class="auto-toc">
<li><a class="reference" href="#id1" id="id18" name="id18">3.1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference" href="#xml-elements" id="id19" name="id19">3.2&nbsp;&nbsp;&nbsp;XML-Elements</a></li>
<li><a class="reference" href="#programmatic-configuration" id="id20" name="id20">3.3&nbsp;&nbsp;&nbsp;Programmatic Configuration</a></li>
<li><a class="reference" href="#client-side-properties" id="id21" name="id21">3.4&nbsp;&nbsp;&nbsp;Client-Side Properties</a></li>
<li><a class="reference" href="#advanced-configuration" id="id22" name="id22">3.5&nbsp;&nbsp;&nbsp;Advanced configuration</a><ul class="auto-toc">
<li><a class="reference" href="#using-datasources" id="id23" name="id23">3.5.1&nbsp;&nbsp;&nbsp;Using DataSources</a></li>
<li><a class="reference" href="#using-loginhandlers" id="id24" name="id24">3.5.2&nbsp;&nbsp;&nbsp;Using LoginHandlers</a></li>
<li><a class="reference" href="#using-named-queries" id="id25" name="id25">3.5.3&nbsp;&nbsp;&nbsp;Using Named-Queries</a></li>
<li><a class="reference" href="#using-query-filters" id="id26" name="id26">3.5.4&nbsp;&nbsp;&nbsp;Using Query-Filters</a><ul class="auto-toc">
<li><a class="reference" href="#combining-named-queries-and-query-filters" id="id27" name="id27">3.5.4.1&nbsp;&nbsp;&nbsp;Combining Named-Queries and Query-Filters</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#logging" id="id28" name="id28">3.6&nbsp;&nbsp;&nbsp;Logging</a></li>
</ul>
</li>
<li><a class="reference" href="#vendor-specific-informations" id="id29" name="id29">4&nbsp;&nbsp;&nbsp;Vendor-Specific informations</a><ul class="auto-toc">
<li><a class="reference" href="#oracle-9i" id="id30" name="id30">4.1&nbsp;&nbsp;&nbsp;Oracle 9i</a></li>
<li><a class="reference" href="#db2-8-2" id="id31" name="id31">4.2&nbsp;&nbsp;&nbsp;DB2 8.2</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id9" name="introduction">1&nbsp;&nbsp;&nbsp;Introduction</a></h1>
<div class="section" id="what-is-vjdbc">
<h2><a class="toc-backref" href="#id10" name="what-is-vjdbc">1.1&nbsp;&nbsp;&nbsp;What is VJDBC ?</a></h2>
<p>VJDBC (Virtual JDBC) is a JDBC type 3 driver which provides a client-server model for remote access of JDBC datasources over different network protocols.</p>
</div>
<div class="section" id="features">
<h2><a class="toc-backref" href="#id11" name="features">1.2&nbsp;&nbsp;&nbsp;Features</a></h2>
<ul>
<li><p class="first">High-Speed</p>
<blockquote>
<p>Communication to the server and delivering of the results are extremely
optimized for highest serialization speed.</p>
</blockquote>
</li>
<li><p class="first">Command-Pattern</p>
<blockquote>
<p>Most method calls on VJDBC-Objects are wrapped in Command-Objects which will 
then be sent to the server-component for processing over <strong>Command-Sinks</strong>. 
A Command-Sink has a very lean interface (actually two methods !) so its very 
easy to provide new Command-Sink-Implementations for other protocols (i.e. 
SOAP, XML-RPC ...).</p>
</blockquote>
</li>
<li><p class="first">Different Command-Sinks provided</p>
<blockquote>
<p>There are actually three Command-Sink-Implementations in the VJDBC-Package: 
RMI, HTTP(S) and EJB. The latter ones are somewhat experimental because they 
don't bother about clustering, EJB container transactions and so on.</p>
</blockquote>
</li>
<li><p class="first">Transparent compression</p>
<blockquote>
<p>Data is transparently compressed to provide good performance in low-bandwidth 
environments.</p>
</blockquote>
</li>
<li><p class="first">Parameter batching</p>
<blockquote>
<p>Parameters for prepared statements and batch updates will be collected on 
the client side until the statement is finally executed.</p>
</blockquote>
</li>
<li><p class="first">Streaming ResultSets</p>
<blockquote>
<p>JDBC-ResultSets can be very large (intentionally or unintentionally). To reduce 
network load and thus provide a faster response ResultSets can be split up 
in multiple sequential row packets by a definable packet size.</p>
</blockquote>
</li>
<li><p class="first">Caching</p>
<blockquote>
<p>Some data doesn't change over the lifetime of a JDBC-Object (i.e. the metadata 
of a PreparedStatement). Such data will be cached on the client-side to reduce 
network load for repeated calls.</p>
</blockquote>
</li>
<li><p class="first">Checking for orphaned connections</p>
<blockquote>
<p>A timer task frequently checks for orphaned connections, there are no dangling 
connections.</p>
</blockquote>
</li>
<li><p class="first">Connection Pooling</p>
<blockquote>
<p>VJDBC optionally uses the Jakarta-DBCP-Package for efficient connection pooling.</p>
</blockquote>
</li>
<li><p class="first">Named-Queries &amp; Query-Filters</p>
<blockquote>
<p>To make the client-server connection more secure VJDBC can be configured to only
allow specific queries. Additionally queries can be filtered through regular
expressions.</p>
</blockquote>
</li>
</ul>
</div>
<div class="section" id="compatibility">
<h2><a class="toc-backref" href="#id12" name="compatibility">1.3&nbsp;&nbsp;&nbsp;Compatibility</a></h2>
<p>VJDBC implements the complete JDBC-API of J2SE 1.4, including SavePoints, Batch-Updates and so on. It certainly depends on the used database drivers if these recent features are available.</p>
<p>VJDBC-ResultSets are read-only, they are not updatable. You will get UnsupportedOperationExceptions when you call the update...() methods. Because updatable ResultSets IMHO aren't use very often (indeed they're quite exotic), this is only a minor drawback.</p>
</div>
</div>
<div class="section" id="supported-protocols">
<h1><a class="toc-backref" href="#id13" name="supported-protocols">2&nbsp;&nbsp;&nbsp;Supported Protocols</a></h1>
<div class="section" id="rmi">
<h2><a class="toc-backref" href="#id14" name="rmi">2.1&nbsp;&nbsp;&nbsp;RMI</a></h2>
<p>Using VJDBC with RMI is almost completely described in the quickstart tutorial, please first take a look at this example to get an idea how RMI access works.</p>
<p>To use VJDBC in RMI-Mode the JDBC connection string must have a specific layout:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">jdbc:vjdbc:rmi:&lt;RMI-URI&gt;,&lt;Connection-Id&gt;</span></tt></blockquote>
<p>The RMI-URI contains the reference to the RMI-Registry and the name of the RMI-Object we want to get a reference to. When you start the RMI-Server without additional parameters you can reach the RMI-Object with the following string:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">jdbc:vjdbc:rmi://localhost:2000/VJdbc,testdb</span></tt></blockquote>
<p>The last part &lt;Connection-Id&gt; is an identifier for the JDBC connection. There can be any number of connection definitions so all clients need to identify the connection they desire to access.</p>
<p>The server-component can now be started with</p>
<blockquote>
<tt class="docutils literal"><span class="pre">java</span> <span class="pre">-classpath</span> <span class="pre">vjdbc.jar;vjdbc_server.jar;commons-beanutils.jar;commons-collections-2.1.1.jar;commons-dbcp-1.2.1.jar;commons-digester.jar;commons-logging.jar;commons-pool-1.2.jar;jakarta-oro-2.0.8.jar;log4j-1.2.8.jar</span> <span class="pre">de.simplicit.vjdbc.server.rmi.ConnectionServer</span> <span class="pre">vjdbc_jdbcodbc_basic.xml</span></tt></blockquote>
<p>The one and only argument is the configuration file which contains the connection definitions for this server process.</p>
</div>
<div class="section" id="http-s-using-servlets">
<h2><a class="toc-backref" href="#id15" name="http-s-using-servlets">2.2&nbsp;&nbsp;&nbsp;HTTP(S) using Servlets</a></h2>
<p>VJDBC can also be used over the HTTP-Protocol by using a servlet on the server-side inside a web-container. With the exception that HTTP is used, all communication is binary encoded, there are no SOAP messages exchanged which would lead to much more network traffic.</p>
<p>The connection string for servlet connections looks like this:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">jdbc:vjdbc:servlet:&lt;HTTP-URL&gt;,&lt;Connection-Id&gt;</span></tt></blockquote>
<p>The HTTP-URL is certainly the URL to our VJDBC-Servlet, for example:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">jdbc:vjdbc:servlet:http://localhost:8080/vjdbc_servlet/vjdbc,testdb</span></tt></blockquote>
<p>The red part is the connection id which must correspond to an identifier specified in the VJDBC configuration file.</p>
<p><strong>Now where must the configuration file be placed ?</strong></p>
<p>In previous versions of VJDBC the configuration had to be put into the environment properties of the servlet. This was quite easy to do but this type of configuration differs for each web container and its problematic when you want to set more complex or nested properties. And if you wanted to reuse the configuration of your intranet RMI server you had to mirror the properties; a quite harsh violation of the DRY principle :-)</p>
<p>Now the configuration is totally external and thus portable. The VJDBC-Servlet searches for the file /WEB-INF/vjdbc-config.xml. Place the configuration file there and everything works exactly the same as the RMI version.</p>
<p><strong>VJDBC &amp; Load-Balancing</strong></p>
<p>Because VJDBC manages the references to the real JDBC-Objects in a singleton class, it is not a good idea to use it in an environment which uses load-balancing: every JVM has its own singleton object and it's not predictable which servlet container will be invoked.</p>
<p>This problem persists even by using sessions. The state of a session can be persisted by the web-container and later be reloaded when the session gets active again. JDBC-Objects can't be persisted so the problem stays the same.</p>
<p>One possible way to resolve the problem is to put the singleton into its own JVM. The servlet container then gets a reference to the singleton (via RMI registry or JNDI) and forwards its commands to it (delegation); implementation of such a mechanism shouldn't be a big thing so stay tuned.</p>
</div>
<div class="section" id="ejb-mode">
<h2><a class="toc-backref" href="#id16" name="ejb-mode">2.3&nbsp;&nbsp;&nbsp;EJB-Mode</a></h2>
<p>To be written ... (basically the same as RMI but also with the load-balancing/clustering problem).</p>
</div>
</div>
<div class="section" id="configuration-usage">
<h1><a class="toc-backref" href="#id17" name="configuration-usage">3&nbsp;&nbsp;&nbsp;Configuration &amp; Usage</a></h1>
<div class="section" id="id1">
<h2><a class="toc-backref" href="#id18" name="id1">3.1&nbsp;&nbsp;&nbsp;Introduction</a></h2>
<p>Configuration of VJDBC is now XML based. The XML structure is translated into configuration objects by Jakarta-Digester, so VJDBC can also be configured completely programatically (more on that topic later). Most of the properties you can use have meaningful default values. This is what the simplest configuration file can look like</p>
<pre class="literal-block">
&lt;vjdbc-configuration&gt;
  &lt;connection id=&quot;testdb&quot; driver=&quot;sun.jdbc.odbc.JdbcOdbcDriver&quot; url=&quot;jdbc:odbc:testdb&quot;/&gt;
&lt;/vjdbc-configuration&gt;
</pre>
<p>There is the root element called <tt class="docutils literal"><span class="pre">&lt;vjdbc-configuration&gt;</span></tt>. It can list as many connections as you want, each with its own set of properties. You can even mix the native drivers. A more complex example for a configuration:</p>
<pre class="literal-block">
&lt;vjdbc-configuration&gt;
    &lt;rmi objectName=&quot;VJdbc&quot; port=&quot;1500&quot; createRegistry=&quot;false&quot;/&gt;
    &lt;connection
       id=&quot;MyDB&quot;
       driver=&quot;sun.jdbc.odbc.JdbcOdbcDriver&quot;
       url=&quot;jdbc:odbc:testdb&quot;
       user=&quot;vjdbc&quot;
       password=&quot;vjdbc&quot;
       rowPacketSize=&quot;100&quot;
       compressionMode=&quot;bestcompression&quot;
       compressionThreshold=&quot;2000&quot;
       connectionPooling=&quot;on&quot;
       loginHandler=&quot;de.simplicit.vjdbc.test.SimpleLoginHandler&quot;&gt;
    &lt;/connection&gt;
    &lt;connection
       id=&quot;QuizDB&quot;
       driver=&quot;com.mysql.jdbc.Driver&quot;
       url=&quot;jdbc:mysql:///quiz&quot;&gt;
    &lt;/connection&gt;
&lt;/vjdbc-configuration&gt;
</pre>
<p>Here you can see three parts.</p>
<p>The &lt;rmi&gt;-Part defines the RMI configuration where the VJdbc-Remote-Object will be registered at an existing RMI-Registry waiting on port 1500.</p>
<p>The first &lt;connection&gt;-Part defines a JDBC-ODBC-Connection to the testdb-ODBC-Datasource incl. the account to use for the connection. Because the network bandwidth is quite low, the rowPacketSize is set to 100. This means more network calls for ResultSet iteration but less data being returned by every call. Compression is set to bestcompression; default is bestspeed. When the size of the returned data doesn't surpass 2000 bytes it won't be compressed. Connection pooling is on to increase performance when opening connections to the database. Finally a special LoginHandler-Class is registered with this connection; each client must provide vjdbc.login.user and vjdbc.login.password. These credentials will be forwarded to the LoginHandler-Class, which can then use any authentication mechanism to authenticate the client.</p>
<p>The second &lt;connection&gt;-Part defines the second connection to a MySQL-Database. Here most of the default values for the configuration are sufficient, only the mandatory properties are specified.</p>
</div>
<div class="section" id="xml-elements">
<h2><a class="toc-backref" href="#id19" name="xml-elements">3.2&nbsp;&nbsp;&nbsp;XML-Elements</a></h2>
<p>The following XML-Tags are used to configure VJDBC with a configuration file. Remember that the attribute keys are case-sensitive.</p>
<ul class="code">
<li><p class="first">&lt;rmi&gt;</p>
<ul>
<li><p class="first">objectName (Default: VJdbc)</p>
<p>Name to be used for registration of the RMI-Object.</p>
</li>
<li><p class="first">port (2000)</p>
<p>Port of the RMI-Registry.</p>
</li>
<li><p class="first">createRegistry (true)</p>
<p>Flag which indicates if the VJDBC-Server shall create a RMI-Registry on the specified port (<strong>true</strong>) or if it shall use an already existing RMI-Registry (<strong>false</strong>).</p>
</li>
<li><p class="first">useSSL (false)</p>
<p>Flag which indicates if SSL shall be used for RMI connections.</p>
</li>
</ul>
</li>
<li><p class="first">&lt;occt&gt;</p>
<p>OCCT stands for &quot;Orphaned-Connection-Collector-Task&quot;. This Timer-Task checks the existing connections if they are orphaned and closes them if they have exceeded a
configurable timeout. As VJDBC is a distributed system the OCCT is important when the client application doesn't clean up the VJDBC-Connections propertly (i. e. it 
crashes and doesn't run through the cleanup code).</p>
<ul>
<li><p class="first">checkingPeriod (Default: 30 sec.)</p>
<p>This is the period after which the OCCT periodically checks the existing connections. You can specify values in milliseconds (&quot;60000&quot;), seconds (&quot;60s&quot;) or 
minutes (&quot;1m&quot;). This value can also be 0 which means that the OCCT isn't used.</p>
<div class="danger">
<p class="first admonition-title">!DANGER!</p>
<p class="last">Turn it off only when you are absolutely sure that all clients close their connections properly otherwise you will end up with dangling JDBC-Connections
that are never closed.</p>
</div>
</li>
<li><p class="first">timeout (Default: 120 sec.)</p>
<p>When a connection is idle since this timeout period it is considered to be orphaned and is cleaned up by the OCCT. You can specify values in milliseconds (&quot;60000&quot;),
seconds (&quot;60s&quot;) or minutes (&quot;1m&quot;).</p>
</li>
</ul>
<p>A sample configuration using a checking period of 120 seconds and a timeout period of 5 minutes.</p>
<blockquote>
<pre class="literal-block">
&lt;occt checkingPeriod=&quot;120s&quot; timeout=&quot;5m&quot;/&gt;
</pre>
</blockquote>
</li>
<li><p class="first">&lt;connection&gt;</p>
<ul>
<li><p class="first">id</p>
<p>Unique identifier which can be used by clients to identify the connection they want to use.</p>
</li>
<li><p class="first">driver</p>
<p>JDBC-Driver class to be used for this connection. <a class="footnote-reference" href="#id7" id="id2" name="id2">[1]</a></p>
</li>
<li><p class="first">url</p>
<p>JDBC-URL for access of the underlying database. <a class="footnote-reference" href="#id7" id="id3" name="id3">[1]</a></p>
</li>
<li><p class="first">dataSourceFactory</p>
<p>Fully qualified name of a class which implements the DataSourceFactory-Interface. This interface has one method which is used to retrieve a DataSource object. <a class="footnote-reference" href="#id7" id="id4" name="id4">[1]</a></p>
</li>
<li><p class="first">user</p>
<p>User-Identifier used to login to the database. <a class="footnote-reference" href="#id8" id="id5" name="id5">[2]</a></p>
</li>
<li><p class="first">password</p>
<p>Password to login to the database. <a class="footnote-reference" href="#id8" id="id6" name="id6">[2]</a></p>
</li>
<li><p class="first">connectionPooling (on)</p>
<p>VJDBC uses the Jakarta DBCP package for connection pooling. With this property you can turn it <strong>on</strong> or <strong>off</strong>.</p>
<div class="attention">
<p class="first admonition-title">Attention!</p>
<p class="last">Connection pooling can only be used when a dataSourceFactory is used or when a user/password is provided. In any other case user-specific database accounts will be used and thus connection pooling must be disabled. One more reason to provide a custom login handler.</p>
</div>
</li>
<li><p class="first">&lt;connection-pool&gt;</p>
<p>Besides the simple connectionPooling-Flag, the DBCP-Pool can be configured with some parameters. This is especially important when idle connections shall be closed after a specified time; by default DBCP holds pooled connections open for infinite time. When this tag is specified connection pooling is automatically turned on.</p>
<ul>
<li><p class="first">maxActive (8)</p>
<p>Maximum number of connections the pool holds. When no more connections are available the call will wait until a connection is released or a SQLException will be raised after a specified timeout.</p>
</li>
<li><p class="first">maxIdle (8)</p>
<p>Maximum number of idle connections in the pool.</p>
</li>
<li><p class="first">minIdle (0)</p>
<p>Minimum number of idle connections in the pool.</p>
</li>
<li><p class="first">maxWait (-1)</p>
<p>Maximum time to wait until an openConnection()-Call will raise a SQLException. -1 means the call waits forever.</p>
</li>
<li><p class="first">timeBetweenEvictionRunsMillis (-1)</p>
<p>DBCP uses the 'Evictor'-Thread to look for idle connections. This thread is only started when this parameter has a positive value, providing the value in milliseconds. The Evictor-Thread then checks every 'timeBetweenEvictionRunsMillis' for idle connections.</p>
</li>
<li><p class="first">minEvictableIdleTimeMillis (1000 * 60 * 30)</p>
<p>The Evictor-Thread closes idle connections which were idle for more than minEvictableIdleTimeMillis</p>
</li>
</ul>
<pre class="literal-block">
&lt;connection
        id=&quot;HSqlDB&quot;
        ...
        &lt;connection-pool 
                   maxActive=&quot;20&quot; 
                   maxIdle=&quot;10&quot;
                   maxWait=&quot;10000&quot;
                   timeBetweenEvictionRunsMillis=&quot;5000&quot;
                   minEvictableIdleTimeMillis=&quot;10000&quot;/&gt;
        ...       
</pre>
</li>
<li><p class="first">rowPacketSize (200)</p>
<p>Number of rows in one row packet which contain the data of a ResultSet. Large ResultSets can be delivered in several sequential row packets to reduce the network load. If this value is 0 the whole ResultSet will be delivered in one big packet.</p>
</li>
<li><p class="first">prefetchResultSetMetaData (false)</p>
<p>Normally when a ResultSet is returned its accompanying ResultSetMetaData isn't delivered. This only happens when someone calls getMetaData() on the ResultSet. If you always call getMetaData() on your ResultSets (say you do some kind of reflection on the ResultSet) it is more efficient to return the ResultSetMetaData together with the ResultSet as one remote call can be saved.</p>
<blockquote>
<div class="attention">
<p class="first admonition-title">Attention!</p>
<p class="last">Another problem strikes depending on your database driver: VJDBC serializes the ResultSet on the server-side so most of the time the server-side ResultSet-Cursor is &quot;empty&quot; (any next() call would return false) after VJDBC returns. Database drivers might be implemented in such a way that they close the ResultSet by themselves without waiting for the client to explicitly close it. But this is crucial for reading the ResultSetMetaData because you can't read the metadata of a closed ResultSet ! So here you also can use the prefetchResultSetMetaData flag. Or if you don't use ResultSetMetaData at all, you can just ignore it !</p>
</div>
</blockquote>
</li>
<li><p class="first">compressionMode (bestspeed)</p>
<p>Compression mode to be used. Possible values: <strong>none</strong>, <strong>bestcompression</strong> or <strong>bestspeed</strong>.</p>
</li>
<li><p class="first">compressionThreshold (2000)</p>
<p>Threshold in number of bytes above which compression will be used. If the size of the data to be transported is lower than this threshold it will be delivered uncompressed because it doesn't really make a difference for the network load and speeds up both server and client because they don't need to compress/decompress the data.</p>
</li>
<li><p class="first">loginHandler</p>
<p>Fully qualified name of a class which implements the LoginHandler interface. This can be used to use another authentication mechanism than the standard db-user and -password combination.</p>
</li>
<li><p class="first">charset (ISO-8859-1)</p>
<p>There is a method called getBinaryStream() in the ResultSet interface which returns an InputStream for the data of a specific column. Because character data is transported as standard Java-UTF-8-Strings the client must have the information which encoding was originally used.</p>
</li>
<li><p class="first">traceCommandCount (false)</p>
<p>Debug-Flag. When its on VJDBC traces a statistic of the commands which were executed on a connection. This way often called commands can be identified and perhaps reduced.</p>
</li>
<li><p class="first">traceOrphanedObjects (false)</p>
<p>Debug-Flag. JDBC-Resources like Connections, Statements or ResultSets should always be freed with the close() method. VJDBC can track the points in the client program which caused the creation of these resources to easily find resource &quot;leaks&quot;.</p>
</li>
<li><p class="first">&lt;named-queries&gt;</p>
<p>See <a class="reference" href="#using-named-queries">Using Named-Queries</a> for more details.</p>
</li>
<li><p class="first">&lt;query-filters&gt;</p>
<p>See <a class="reference" href="#using-query-filters">Using Query-Filters</a> for more details.</p>
</li>
</ul>
</li>
</ul>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a name="id7">[1]</a></td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id3">2</a>, <a class="fn-backref" href="#id4">3</a>)</em> Either the Driver/URL-Combination or the DataSourceFactory must be specified. If both are specified the DataSource Factory
is used</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a name="id8">[2]</a></td><td><em>(<a class="fn-backref" href="#id5">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> If User/Password isn't specified in the configuration the VJDBC client must provide these properties</td></tr>
</tbody>
</table>
</div>
<div class="section" id="programmatic-configuration">
<h2><a class="toc-backref" href="#id20" name="programmatic-configuration">3.3&nbsp;&nbsp;&nbsp;Programmatic Configuration</a></h2>
<p>The XML configuration is actually translated by Jakarta-Digester into a structure of configuration objects. These objects can be built programmatically for usage. You can for example embed a VJDBC RMI-Server into an already running server process by using this approach; no need for external configuration files anymore.</p>
<pre class="literal-block">
public class CustomRmiServer {
    public static void main(String[] args) {
        BasicConfigurator.configure();
        Logger.getRootLogger().setLevel(Level.INFO);

        try {
            // Initialize VJDBC programmatically
            System.out.println(&quot;Initializing VJDBC&quot;);
            VJdbcConfiguration vjdbcConfig = new VJdbcConfiguration();

            // Connection-Configuration for Oracle
            ConnectionConfiguration configOracle = new ConnectionConfiguration();
            configOracle.setDriver(&quot;oracle.jdbc.OracleDriver&quot;);
            configOracle.setId(&quot;OracleDB&quot;);
            configOracle.setUrl(&quot;jdbc:oracle:oci:&#64;&quot;);
            configOracle.setConnectionPooling(true);
            vjdbcConfig.addConnection(configOracle);

            // Connection-Configuration for Oracle
            ConnectionConfiguration configOdbc = new ConnectionConfiguration();
            configOdbc.setDriver(&quot;sun.jdbc.odbc.JdbcOdbcDriver&quot;);
            configOdbc.setId(&quot;MyDB&quot;);
            configOdbc.setUrl(&quot;jdbc:odbc:testdb&quot;);
            configOdbc.setConnectionPooling(true);
            vjdbcConfig.addConnection(configOdbc);

            // Finally initialize VJDBC and start the server
            VJdbcConfiguration.init(vjdbcConfig);
            ConnectionServer server = new ConnectionServer();
            server.serve();
        } catch(Exception e) {
            e.printStackTrace();
        }
    }
}
</pre>
</div>
<div class="section" id="client-side-properties">
<h2><a class="toc-backref" href="#id21" name="client-side-properties">3.4&nbsp;&nbsp;&nbsp;Client-Side Properties</a></h2>
<p>You can set different VJDBC-specific properties in the Properties-Object that is passed to the getConnection-Method of the DriverManager. Use the static strings in the VJdbcProperties class as the keys.</p>
<ul>
<li><p class="first">VJdbcProperties.LOGIN_USER</p>
<p>User-Id which will be used by the optional LoginHandler on the server to verify the access of the user (don't mix this up with the database user-id)</p>
</li>
<li><p class="first">VJdbcProperties.LOGIN_PASSWORD</p>
<p>Password for the user.</p>
</li>
<li><p class="first">VJdbcProperties.CLIENTINFO_PROPERTIES</p>
<p>VJDBC can pass client-side system properties to the server which logs them when the connection is closed. This can be used to monitor which users connect, what operation system the client runs on etc. Just pass a list of the property keys in a semicolon-separated string (i. e. <tt class="docutils literal"><span class="pre">user.name;java.version;os.name</span></tt>)</p>
</li>
<li><p class="first">VJdbcProperties.RMI_SSL</p>
<p>Signaling using of SSL sockets for RMI communication (true or false, default: false)</p>
</li>
<li><p class="first">VJdbcProperties.CACHE_TABLES</p>
<p>List of tables which will be cached on the client by using HSQL-DB. Format of the string is <tt class="docutils literal"><span class="pre">{tablename[:refresh-interval],tablename[:refresh-interval]...}</span></tt></p>
</li>
</ul>
</div>
<div class="section" id="advanced-configuration">
<h2><a class="toc-backref" href="#id22" name="advanced-configuration">3.5&nbsp;&nbsp;&nbsp;Advanced configuration</a></h2>
<div class="section" id="using-datasources">
<h3><a class="toc-backref" href="#id23" name="using-datasources">3.5.1&nbsp;&nbsp;&nbsp;Using DataSources</a></h3>
<p>By default VJDBC gets the connection to the backend database by using a standard JDBC-URL.</p>
<p>Java 1.4 introduced the DataSource-API as an alternative. The DataSource-API is more flexible and easier to use in environments such as application servers or directory services.</p>
<p>To get VJDBC working with the DataSource-API you need to provide a class that implements the DataSourceProvider interface. You must then specify this class in the VJDBC-Configuration. VJDBC will instantiate this class (thus it must have a constructor without parameters) and call the getDataSource() method to finally get the DataSource.</p>
<p>A simple example using HSQL-DB. First the very basic implementation of a DataSource class. This is just for demonstration purposes, you normally wouldn't implement this class but use the class provided by your database vendor.</p>
<pre class="literal-block">
/*
Simple DataSource implementation
*/
public class HSqlDataSource implements DataSource {
    public HSqlDataSource() throws SQLException {
        try {
            Class.forName(&quot;org.hsqldb.jdbcDriver&quot;);
        } catch (ClassNotFoundException e) {
            throw new SQLException(e.getMessage());
        }
    }

    ...

    public Connection getConnection() throws SQLException {
        return DriverManager.getConnection(&quot;jdbc:hsqldb:.&quot;);
    }

    public Connection getConnection(String username, String password) throws SQLException {
        return DriverManager.getConnection(&quot;jdbc:hsqldb:.&quot;, username, password);
    }
}
</pre>
<p>Now the DataSourceProvider implementation for VJDBC</p>
<pre class="literal-block">
package de.simplicit.vjdbc.test.junit.hsqldb;

import java.sql.SQLException;
import javax.sql.DataSource;
import de.simplicit.vjdbc.server.DataSourceProvider;

public class HSqlDataSourceProvider implements DataSourceProvider {
    public DataSource getDataSource() throws SQLException {
        return new HSqlDataSource();
    }
}
</pre>
<p>Finally we must specify the DataSourceProvider class in our configuration</p>
<pre class="literal-block">
&lt;connection
    id=&quot;HSqlDB-DataSource&quot;
    dataSourceProvider=&quot;de.simplicit.vjdbc.test.junit.hsqldb.HSqlDataSourceProvider&quot;
    user=&quot;sa&quot;
    password=&quot;&quot;
    ...
</pre>
</div>
<div class="section" id="using-loginhandlers">
<h3><a class="toc-backref" href="#id24" name="using-loginhandlers">3.5.2&nbsp;&nbsp;&nbsp;Using LoginHandlers</a></h3>
<p>VJDBC behaves like a normal JDBC driver so it is necessary to provide user and password for the database login.</p>
<p>This can be a problem because you must specify the user/password combination on the client side. A malicious user could look into the Java byte code to find the user/password information and then try to login to the database completely out of the context of the original scenario. Bad things can happen when this user-login has advanced privileges ...</p>
<p>VJDBC offers a simple mechanism to replace the database login with a different login mechanism (JAAS for example). To use this mechanism you must provide a LoginHandler class which checks the credentials of the client.</p>
<p>The following example explains the concept. Say you want to manage the VJDBC users with an ordinary properties file called user.properties.</p>
<pre class="literal-block">
# Format
# User=Password
mike=secret
gerry=cool
</pre>
<p>Now write the class that implements the LoginHandler interface and reads the user.properties file</p>
<pre class="literal-block">
package de.simplicit.vjdbc.test;

import de.simplicit.vjdbc.VJdbcException;
import de.simplicit.vjdbc.server.LoginHandler;

import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

public class SimpleLoginHandler implements LoginHandler {
    private Properties _properties = new Properties();

    public SimpleLoginHandler() throws IOException {
        InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;de/simplicit/vjdbc/test/user.properties&quot;);
        _properties.load(is);
    }

    // When the login of the user fails, just throw a VJdbcException
    public void checkLogin(String user, String password) throws VJdbcException {
        if (user != null) {
            String pw = _properties.getProperty(user);

            if (pw != null) {
                if (!pw.equals(password)) {
                    throw new VJdbcException(&quot;Password for user &quot; + user + &quot; is wrong&quot;);
                }
            } else {
                throw new VJdbcException(&quot;Unknown user &quot; + user);
            }
        } else {
            throw new VJdbcException(&quot;User is null&quot;);
        }
    }
}
</pre>
<div class="attention">
<p class="first admonition-title">Attention!</p>
<p>VJDBC differentiates between the user/password combination for the database and for the custom login mechanism. User/Password for the latter must be provided in the Properties object that is handed over to the DriverManager on the client side. Use the identifier provided by the VJdbcProperties class to put the information into the properties.</p>
<pre class="last literal-block">
Properties props = new Properties();
props.setProperty(VJdbcProperties.LOGIN_USER, &quot;mike&quot;);
props.setProperty(VJdbcProperties.LOGIN_PASSWORD, &quot;secret&quot;);

_connection = DriverManager.getConnection(&quot;jdbc:vjdbc:rmi://localhost:2345/VJdbc,MyDB&quot;, props);
</pre>
</div>
</div>
<div class="section" id="using-named-queries">
<h3><a class="toc-backref" href="#id25" name="using-named-queries">3.5.3&nbsp;&nbsp;&nbsp;Using Named-Queries</a></h3>
<p>By using Named-Queries you can replace the SQL strings in your application with identifiers. VJDBC replaces these identifiers on-the-fly with the SQL statement that you provide with the configuration. An identifier starts with a dollar sign and must be unique for a connection configuration. The Named-Queries must be listed in the &lt;named-queries&gt; element of the connection:</p>
<pre class="literal-block">
&lt;connection
    id=&quot;HSqlDB&quot;
    ...
    &lt;named-queries&gt;
        &lt;entry id=&quot;selectAllAddresses&quot;&gt;select * from Address&lt;/entry&gt;
        &lt;entry id=&quot;updateAllAddresses&quot;&gt;update Address set name = 'Balla' where name = 'Billi'&lt;/entry&gt;
        ...
    &lt;/named-queries&gt;
</pre>
<p>In the application you must pass the id-String preceded with a dollar-sign instead of SQL.</p>
<pre class="literal-block">
Connection connVJdbc = createVJdbcConnection();
PreparedStatement pstmt2 = connVJdbc.prepareStatement(&quot;$selectAllAddresses&quot;);
ResultSet rs1 = pstmt1.executeQuery();
...
</pre>
</div>
<div class="section" id="using-query-filters">
<h3><a class="toc-backref" href="#id26" name="using-query-filters">3.5.4&nbsp;&nbsp;&nbsp;Using Query-Filters</a></h3>
<p>With Query-Filters it is possible to check the supplied SQL against standard regular expressions. That way you can prevent malicious queries to come through to the backend database. Like Named-Queries the Query-Filters are specified in the configuration of VJDBC:</p>
<pre class="literal-block">
&lt;connection
    id=&quot;HSqlDB&quot;
    driver=&quot;org.hsqldb.jdbcDriver&quot;
    url=&quot;jdbc:hsqldb:.&quot;
            ...
    &lt;named-queries&gt;
        &lt;entry id=&quot;selectAllAddresses&quot;&gt;select * from Address&lt;/entry&gt;
        &lt;entry id=&quot;updateAllAddresses&quot;&gt;update Address set name = 'Balla' where name = 'Billi'&lt;/entry&gt;
    &lt;/named-queries&gt;
    &lt;query-filters&gt;
        &lt;allow&gt;insert .+&lt;/allow&gt;
        &lt;allow&gt;SeLeCt .+&lt;/allow&gt;
        &lt;allow&gt;CREATE .+&lt;/allow&gt;
        &lt;allow&gt;update .+&lt;/allow&gt;
        &lt;allow&gt;drop table .+&lt;/allow&gt;
        &lt;deny&gt;.+&lt;/deny&gt;
    &lt;/query-filters&gt;
&lt;/connection&gt;
</pre>
<p>Two types of Query-Filters are currently available, the Allow-Filter and the Deny-Filter. You can specify any number of those filters to create a complete chain of filters. VJDBC will check each SQL statement against those filters; if an Allow-Filter matches, the filter-check stops and the statement will be executed. If a Deny-Filter matches, the filter-check stops and a SQLException will be thrown to notify the client. If no match is found, the statement is <strong>NOT</strong> executed, so no malicious statements can fall through.</p>
<p>Query-Filters are case-insensitive as you can see in the example above.</p>
<p>By default all SQL strings are checked if they <em>match</em> the regular expression completely. You can also specify that the SQL string only <em>contains</em> the regex pattern by adding a <tt class="docutils literal"><span class="pre">type</span></tt> attribute to the filter. If you want to reject all SQL statements that contain &quot;delete&quot;, you can specify the following Deny-Filter</p>
<pre class="literal-block">
&lt;deny type=&quot;contains&quot;&gt;delete&lt;/deny&gt;
</pre>
<p>This way you don't need to add regex characters for handling &quot;noise&quot; like white space.</p>
<div class="section" id="combining-named-queries-and-query-filters">
<h4><a class="toc-backref" href="#id27" name="combining-named-queries-and-query-filters">3.5.4.1&nbsp;&nbsp;&nbsp;Combining Named-Queries and Query-Filters</a></h4>
<p>By combining Named-Queries and Query-Filters you can make your application flexible and secure. Named-Queries are <strong>not</strong> checked against Query-Filters after resolution of the identifier. Say you want to prevent the execution of &quot;uncontrolled&quot; Delete- and Drop-Statements. You could start with a configuration like this:</p>
<pre class="literal-block">
&lt;named-queries&gt;
    &lt;entry id=&quot;deleteAddress&quot;&gt;delete from Address where Id = ?&lt;/entry&gt;
&lt;/named-queries&gt;
&lt;query-filters&gt;
    &lt;deny type=&quot;contains&quot;&gt;delete&lt;/deny&gt;
    &lt;deny type=&quot;contains&quot;&gt;drop&lt;/deny&gt;
&lt;/query-filters&gt;
</pre>
<p>Here all Delete- and Drop-Statements are denied except the one specified in the Named-Query.</p>
</div>
</div>
</div>
<div class="section" id="logging">
<h2><a class="toc-backref" href="#id28" name="logging">3.6&nbsp;&nbsp;&nbsp;Logging</a></h2>
<p>VJDBC uses the Jakarta-Package Commons-Logging for tracing information about what's happening at the moment. With Commons-Logging you can switch your Logging implementation very easily (i.e. from Log4J to JDK1.4-Logging or vice versa). There is even a simple logging implementation included for output on stderr.</p>
<p>To use Log4J-Logging you only have to include the Log4J-Package in the classpath plus a file called log4j.properties which must be reachable for the classloader. Nothing more to do !</p>
</div>
</div>
<div class="section" id="vendor-specific-informations">
<h1><a class="toc-backref" href="#id29" name="vendor-specific-informations">4&nbsp;&nbsp;&nbsp;Vendor-Specific informations</a></h1>
<p>VJDBC should work with any JDBC compliant driver but as always reality isn't 100%. All vendor specific issues will be collected and written down in the following chapters.</p>
<div class="section" id="oracle-9i">
<h2><a class="toc-backref" href="#id30" name="oracle-9i">4.1&nbsp;&nbsp;&nbsp;Oracle 9i</a></h2>
<ul class="simple">
<li>Driver: ojdbc14.jar, nls_charset12.jar</li>
</ul>
<p>The Oracle thin driver seems to have a limit of 4k for CLOBs. The following code fragment produces an exception <tt class="docutils literal"><span class="pre">java.sql.SQLException:</span> <span class="pre">E/A-Exception:</span> <span class="pre">Connection</span> <span class="pre">reset</span></tt></p>
<pre class="literal-block">
// Creating the table
    stmt.executeUpdate(&quot;create table clobs (id int, someclob clob)&quot;);
    ...
    // a little bit later I try to write some CLOBs
    for(int i = 0; i &lt; 1000; i++) {
            sb.append(&quot;CLOBDATA&quot;);
    }
    String clobdata = sb.toString();
    PreparedStatement pstmt = conn.prepareStatement(&quot;insert into clobs values(?, ?)&quot;);
    for(int i = 1; i &lt;= 10; i++) {
            pstmt.setInt(1, i);
            pstmt.setCharacterStream(2, new StringReader(clobdata), clobdata.length());
            pstmt.executeUpdate();
    }
    pstmt.close();
</pre>
<p>When I set the upper-limit of the first for-loop to 100 (instead of 8000 characters there are 800 characters) everything works fine !</p>
</div>
<div class="section" id="db2-8-2">
<h2><a class="toc-backref" href="#id31" name="db2-8-2">4.2&nbsp;&nbsp;&nbsp;DB2 8.2</a></h2>
<ul class="simple">
<li>Driver: db2jcc.jar, db2jcc_license_cu.jar</li>
</ul>
<p>This driver seems to close ResultSets when the last row was passed by the cursor. A succeeding getMetaData() call fails with &quot;resultset is closed&quot;. The connection flag &quot;prefetchResultSetMetaData&quot; can be used to immediately read the meta data before the resultset is closed.</p>
</div>
</div>
</div>
</body>
</html>
